using System.Threading.Tasks;
using Content.Client.UserInterface.Controls;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Robust.Client.UserInterface.Controls;
using Robust.Shared.Utility;
using Robust.Client.Graphics;
using Robust.Client.UserInterface;
using Robust.Shared.Input;
using Robust.Client.Input;
using Content.Shared._WL.StationaryComputer;
using Robust.Client.ResourceManagement;
using Robust.Shared.Prototypes;
using Robust.Client.UserInterface.RichText;

namespace Content.Client._WL.UserInterface.Systems.Computers;

[GenerateTypedNameReferences]
public sealed partial class StationaryComputerWindow : FancyWindow
{
    [Dependency] private readonly IResourceCache _resCache = default!;
    [Dependency] private readonly IPrototypeManager _protoMan = default!;
    [Dependency] private readonly IClipboardManager _clipboard = default!;
    [Dependency] private readonly ILogManager _logMan = default!;

    public Color ConsoleColor { get; private set; } = Color.White;
    public string CurrentRoot { get; private set; } = string.Empty;

    public const string RootPostfix = ">";
    public const int MaxLineLength = 1024;

    public static readonly ProtoId<FontPrototype> FontPrototypeId = "Consolas";

    public event Action<CmdLineEdit.CmdLineCommandEntry>? OnCommandEntered;

    private readonly List<Label> _lines;
    private bool _hasPendingCommand;

    private readonly VectorFont _font;

    private readonly ISawmill _sawmill;

    public StationaryComputerWindow()
    {
        RobustXamlLoader.Load(this);
        IoCManager.InjectDependencies(this);

        _sawmill = _logMan.GetSawmill("stationary.computer");

        _lines = new();

        MouseFilter = MouseFilterMode.Stop;

        InputLine.OnTextChanged += _ =>
        {
            Caret.ResetAnimation();
        };

        InputLine.OnCommandEntered += entry =>
        {
            Caret.ResetAnimation();

            OnCommandEntered?.Invoke(entry);

            LockConsole();
        };

        var fontProto = _protoMan.Index(FontPrototypeId);
        _font = new VectorFont(_resCache.GetResource<FontResource>(fontProto.Path), 12);

        DiscPathLabel.FontOverride = _font;
        InputLine.OverrideFont = _font;
    }

    public void SetInputEnabled(bool value)
    {
        InputLine.SetInputEnabled(value);
    }

    public void UnlockConsole()
    {
        if (!_hasPendingCommand)
            return;

        _hasPendingCommand = false;
        SetInputEnabled(true);
    }

    public void LockConsole()
    {
        if (!_hasPendingCommand)
            return;

        _hasPendingCommand = true;
        SetInputEnabled(false);
    }

    public void AddOutputLine(string? root, string text = "\0") // чтобы label занимал место.
    {
        text = EnsureText(text);

        var label = new Label
        {
            ReservesSpace = true,
            Margin = new Thickness(4, 0),
            Modulate = ConsoleColor,
            Text = root != null ? $"{root}{RootPostfix} {text}" : text,
            FontOverride = _font,
            MouseFilter = MouseFilterMode.Stop,
        };

        label.OnKeyBindDown += args =>
        {
            if (args.Function == EngineKeyFunctions.UIClick)
            {
                try
                {
                    _clipboard.SetText(text);
                }
                catch (Exception ex)
                {
                    _sawmill.Warning(ex.ToStringBetter());
                }

                InputLine.GrabKeyboardFocus();
                args.Handle();
            }
        };

        MainBoxContainer.AddChild(label);

        label.DoStyleUpdate();

        OutputScroll.InvalidateMeasure();
        OutputScroll.InvalidateArrange();

        UserInterfaceManager.DeferAction(() =>
        {
            OutputScroll.InvalidateMeasure();
            OutputScroll.InvalidateArrange();
            OutputScroll.VScrollBar.MoveToEnd();
        });

        _lines.Add(label);
    }

    public static string EnsureText(string text)
    {
        if (string.IsNullOrWhiteSpace(text))
            return "\0";

        text = FormattedMessage.EscapeText(text);
        text = FormattedMessage.RemoveMarkupPermissive(text);

        if (text.Length > MaxLineLength)
            text = text[..(MaxLineLength + 1)];

        return text;
    }

    public void SetConsoleColor(Color color)
    {
        ConsoleColor = color;

        foreach (var label in _lines)
        {
            UpdateLabelColor(label);
        }

        DiscPathLabel.Modulate = ConsoleColor;
        Caret.Color = ConsoleColor;
        InputLine.Modulate = ConsoleColor;
    }

    public void ClearConsole()
    {
        MainBoxContainer.RemoveAllChildren();
        _lines.Clear();
    }

    public void SetRoot(string root)
    {
        CurrentRoot = root;
        DiscPathLabel.Text = root + RootPostfix;
    }

    private void UpdateLabelColor(Label label)
    {
        label.Modulate = ConsoleColor;
    }

    protected override void Opened()
    {
        base.Opened();

        InputLine.GrabKeyboardFocus();
    }

    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        if (args.Function == EngineKeyFunctions.UIClick && !InputLine.HasKeyboardFocus())
        {
            InputLine.GrabKeyboardFocus();
            args.Handle();
        }

        base.KeyBindDown(args);
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        if (args.Function == EngineKeyFunctions.UIClick)
        {
            InputLine.GrabKeyboardFocus();
            args.Handle();
        }
    }
}
